#' Calculate Site-Based Species Occurrence Across Time Slices
#'
#' This auxiliary function determines which species occur at which sites within
#' each time slice, creating presence/absence matrices for fossil assemblages.
#' It filters occurrence records based on temporal overlap with time slices and
#' generates site-by-species matrices that can be used for downstream community
#' ecology analyses.
#'
#' @param spp_slice A named list where each element contains a character vector
#'     of species names present in a given time slice. Names of list elements
#'     should be time slice identifiers (typically numeric values). Usually
#'     generated by \code{calc_spp_slice()}.
#' @param df.occ A data frame containing fossil occurrence records with at least
#'     four columns: species names, minimum age, maximum age, and site location ID.
#'     Each row represents a single occurrence record at a specific site.
#' @param species Character. The name of the column in \code{df.occ} containing
#'     species identifiers. Default is "species".
#' @param Max.age Character. The name of the column in \code{df.occ} containing
#'     the maximum (oldest) age estimate for each occurrence record. Default is "Max.age".
#' @param Min.age Character. The name of the column in \code{df.occ} containing
#'     the minimum (youngest) age estimate for each occurrence record. Default is "Min.age".
#' @param site Character. The name of the column in \code{df.occ} containing
#'     site location identifiers. Default is "site".
#'
#' @return A list with length equal to the number of time slices in \code{spp_slice}.
#'     Each element is a data frame in wide format representing a site-by-species
#'     presence/absence matrix, with the following structure:
#'     \itemize{
#'       \item First column: \code{site} - Site identifiers
#'       \item Subsequent columns: Species names as column headers, with values
#'             of 1 (present) or 0 (absent) indicating occurrence at each site
#'     }
#'
#' @details
#' The function performs the following steps for each time slice:
#' \enumerate{
#'   \item Filters \code{df.occ} to include only species present in the time slice
#'         (based on \code{spp_slice})
#'   \item Further filters occurrences where the age range overlaps with the time slice
#'         (Max.age >= time slice AND Min.age <= time slice)
#'   \item Groups occurrences by site and removes duplicate species records
#'   \item Creates a presence/absence matrix with sites as rows and species as columns
#'   \item Returns the matrix in wide format suitable for community ecology analyses
#' }
#'
#' This function is typically used internally to prepare occurrence data for
#' calculating co-occurrence patterns, trait distances, or other community-level
#' metrics at the site scale.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Create example species composition per time slice
#' spp_slice <- list(
#'   "100" = c("sp1", "sp2", "sp3"),
#'   "90" = c("sp1", "sp2", "sp4"),
#'   "80" = c("sp2", "sp3", "sp4")
#' )
#'
#' # Create example occurrence data
#' df_occurrences <- data.frame(
#'   species = c("sp1", "sp1", "sp2", "sp2", "sp3", "sp4"),
#'   Max.age = c(100, 95, 100, 90, 95, 85),
#'   Min.age = c(90, 85, 80, 75, 80, 70),
#'   site = c("site1", "site2", "site1", "site2", "site1", "site2")
#' )
#'
#' # Generate site occurrence matrices for each time slice
#' site_matrices <- comp_site_occurrence(
#'   spp_slice = spp_slice,
#'   df.occ = df_occurrences
#' )
#'
#' # View first time slice matrix
#' site_matrices[[1]]
#'
#' # Convert to traditional matrix format for analysis
#' mat_slice1 <- as.matrix(site_matrices[[1]][, -1])
#' rownames(mat_slice1) <- site_matrices[[1]]$site
#'
#' # Calculate species richness per site
#' richness_per_site <- rowSums(mat_slice1)
#'
#' # Calculate beta diversity between sites
#' library(vegan)
#' beta_div <- vegdist(mat_slice1, method = "jaccard")
#' }
comp_site_occurrence <-
  function(spp_slice,
           df.occ,
           species = "species",
           Max.age = "Max.age",
           Min.age = "Min.age",
           site = "site"){

    df_occ <-
      df.occ[, c(species, Max.age, Min.age, site)]
    vars <- list(species, Max.age, Min.age, site)
    name_vars <- c("species", "Max.age", "Min.age", "site")
    names(vars) <- name_vars
    column.names <- names(unlist(vars))
    colnames(df_occ) <- column.names
    df_occ$site <- as.factor(df_occ$site)

    # data frame with species per slice
    list_site_interval <-
      # x = 1
      lapply(1:length(spp_slice), function(x){
        names_slices <- names(spp_slice)[[x]]
        names_species <- spp_slice[[x]]
        filtered_df <-
          df_occ |> filter(species %in% names_species)

        filtered_df_site <-
          filtered_df |>
          filter(Max.age >= as.numeric(names_slices) & Min.age <= as.numeric(names_slices))

        spp_coex_site <-
          filtered_df_site |>
          distinct(species, .keep_all = TRUE) |>
          select(species, Max.age, Min.age)

        filtered_df_site2 <-
          filtered_df_site |>
          group_by(site) |>
          distinct(species, .keep_all = T) |>
          add_count(site, name = "species.per.site") |>
          select(species, site, Max.age, Min.age, species.per.site)

        return(filtered_df_site2)
      })

    # calculate species cooccurrence matrix for each timeslice besed on site cooccurrence
    list_matrix_occurrence_site <-
      lapply(list_site_interval, function(x){

        # Step 1: Remove duplicates to avoid counting same species twice in a site
        df_unique <-
          x |>
          distinct(site, species)

        # Step 2: Create a sites x species data frame
        site_species_matrix <-
          df_unique  |>
          mutate(present = 1) |>
          tidyr::pivot_wider(names_from = species, values_from = present, values_fill = 0)

        # Step 3: return the site x species data frame
        site_species_matrix
      })

    return(list_matrix_occurrence_site)
  }
